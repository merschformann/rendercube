<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>My first three.js app</title>
        <style>
            body {
                margin: 0;
            }
        </style>
    </head>
    <body>
        <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.min.js"></script> -->
        <script src="https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.js"></script>

        <script type="module">
            import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js";
            import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/postprocessing/EffectComposer.js";
            import { GlitchPass } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/postprocessing/GlitchPass.js";
            import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/postprocessing/RenderPass.js";
            // import { OutputPass } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/postprocessing/OutputPass.js";

            // import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.min.js';

            console.log(THREE);

            var data = JSON.parse(`{{solution}}`);
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            scene.background = new THREE.Color(0xf0f0f0);
            scene.background = new THREE.Color(0x000000);
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const light = new THREE.DirectionalLight(0xffffff, 0.7);
            light.position.set(1, 1, 0.5).normalize();
            scene.add(light);

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.antialias = true;
            document.body.appendChild(renderer.domElement);

            // Add controls
            const controls = new OrbitControls(camera, renderer.domElement);

            // Count pieces in all containers
            let pieceCount = 0;
            data.containers.forEach((container) => {
                pieceCount += container.assignments.length;
            });

            // Create rainbow color for each piece
            const colors = [];
            for (let i = 0; i < pieceCount; i++) {
                colors.push(
                    new THREE.Color(`hsl(${(i * 360) / pieceCount}, 100%, 50%)`)
                );
            }

            // Create visuals for all elements
            const containers = [];
            pieceCount = 0;
            let containerOffset = 0;
            data.containers.forEach((container) => {
                // Create visual for container content
                const contentVisual = new THREE.Group();
                contentVisual.name = `Container ${container.id}`;
                for (let i = 0; i < container.assignments.length; i++) {
                    const piece = container.assignments[i];
                    console.log(piece);
                    const pieceVisual = new THREE.Group();
                    pieceVisual.name = `Piece ${piece.id}`;
                    piece.cubes.forEach((cube) => {
                        console.log(cube);
                        const cubeGroup = new THREE.Group();
                        const geometry = new THREE.BoxGeometry(
                            cube.length,
                            cube.width,
                            cube.height
                        );
                        const material = new THREE.MeshPhongMaterial({
                            color: colors[pieceCount],
                        });
                        const cubeVisual = new THREE.Mesh(geometry, material);
                        cubeVisual.position.set(
                            containerOffset + piece.position.x + cube.x + cube.length / 2,
                            piece.position.y + cube.y + cube.width / 2,
                            piece.position.z + cube.z + cube.height / 2
                        );
                        pieceVisual.add(cubeVisual);
                        pieceCount++;
                    });
                    // pieceVisual.position.set(
                    //     piece.position.x + ,
                    //     piece.position.y,
                    //     piece.position.z
                    // );
                    contentVisual.add(pieceVisual);
                }
                containers.push(contentVisual);
                scene.add(contentVisual);
                // Create visual for container itself
                const containerVisual = new THREE.Group();
                console.log(container.length, container.width, container.height);
                const geometry = new THREE.BoxGeometry(
                    container.length,
                    container.width,
                    container.height
                );
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(`hsl(0, 0%, 100%)`),
                });
                material.wireframe = true;
                const containerMesh = new THREE.Mesh(geometry, material);
                containerVisual.add(containerMesh);
                containerVisual.position.set(
                    containerOffset + container.length / 2,
                    0 + container.width / 2,
                    0 + container.height / 2
                );
                scene.add(containerVisual);
                // Move to next container
                containerOffset += container.length + 0.5;
            });

            camera.position.z = 5;

            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass( scene, camera );
            composer.addPass( renderPass );
            // const glitchPass = new GlitchPass();
            // composer.addPass( glitchPass );
            // const outputPass = new OutputPass();
            // composer.addPass( outputPass );

            function animate() {
                requestAnimationFrame(animate);

                // containers.forEach(packing => {
                //     packing.rotation.x += 0.01;
                //     packing.rotation.y += 0.01;
                // });

                // renderer.render(scene, camera);
                composer.render();
            }

            animate();
        </script>
    </body>
</html>
